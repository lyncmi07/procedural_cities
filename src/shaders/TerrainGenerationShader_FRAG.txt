//#version 400 core //(windows)
#version 130 //(linux)

in vec3 position_pass;

out vec4 out_Color;


float getOutputShade(float x, float y, float z)
{
	float shade = tan(x*0.1) * tan(2*y) * sin(4*x) / cos(8.3*x) / cos(2.5*y) +  sin(4.2*x) * tan(2.6*x) + tan(y+x);
	shade = 0.5*(sin(shade + z)+1);
	return shade;
}

float getScalePass(float divisionNumber)
{
	float x = gl_FragCoord.x + position_pass.x;
	float y = gl_FragCoord.y + position_pass.y;
	float z = position_pass.z;
	float xRem = mod(x,divisionNumber);
	float yRem = mod(y,divisionNumber);
	float x1 = floor(x/divisionNumber)*divisionNumber;
	float y1 = floor(y/divisionNumber)*divisionNumber;
	float x2 = x1 + divisionNumber;
	float y2 = y1 + divisionNumber;
	float q11 = getOutputShade(x1,y1,z);
	float q12 = getOutputShade(x1,y2,z);
	float q21 = getOutputShade(x2,y1,z);
	float q22 = getOutputShade(x2,y2,z);

	float fx1 = ((x2 - x)/(x2 - x1) * q11) + 
				((x - x1)/(x2 - x1) * q21);
				
	float fx2 = ((x2 - x)/(x2 - x1) * q12) + 
				((x - x1)/(x2 - x1) * q22);
				
	float fxy = ((y2 - y)/(y2 - y1) * fx1) +
				((y - y1)/(y2 - y1) * fx2);

	return fxy;
}

float getTrigGenerationImage(int passes)
{
	float outputShade = getScalePass(pow(2,passes));
	for(int i = passes-1; i >= 0; i--)
	{
		outputShade += (((getScalePass(pow(2, i)))
							/ (pow(2,passes) * (1 / pow(2,i))))
								- (pow(2.0,i)/pow(2.0,passes+1)));
	}
	
	/*if(outputShade > 0.5)	//for land sea map
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}*/		
	
	return outputShade;
}

void main(void)
{
	float outputShade = getTrigGenerationImage(6);

	out_Color = vec4(outputShade, outputShade, outputShade, 1.0);

}